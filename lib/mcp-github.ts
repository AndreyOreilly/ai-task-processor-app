import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'

export class MCPGitHubService {
  private client: Client | null = null
  private isConnected = false

  constructor() {
    // MCP GitHub —Å–µ—Ä–≤–µ—Ä –±—É–¥–µ—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ
    this.client = null
  }

  async connect() {
    if (this.isConnected) return

    try {
      // –°–æ–∑–¥–∞–µ–º MCP –∫–ª–∏–µ–Ω—Ç –¥–ª—è GitHub
      const transport = new StdioClientTransport({
        command: 'npx',
        args: ['-y', '@modelcontextprotocol/server-github']
      })

      this.client = new Client({
        name: 'ai-task-processor',
        version: '1.0.0'
      }, {
        capabilities: {
          tools: {}
        }
      })

      await this.client.connect(transport)
      this.isConnected = true
      console.log('‚úÖ MCP GitHub —Å–µ—Ä–≤–µ—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω')
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MCP GitHub:', error)
      throw new Error('Failed to connect to MCP GitHub server')
    }
  }

  async createPullRequest(data: {
    taskDescription: string
    analysis: string
    generatedCode: string
    fileName: string
  }) {
    if (!this.client || !this.isConnected) {
      await this.connect()
    }

    const { taskDescription, analysis, generatedCode, fileName } = data

    try {
      // –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª —Å –∫–æ–¥–æ–º
      const fileContent = this.createFileContent(taskDescription, analysis, generatedCode)
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º MCP –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ñ–∞–π–ª–∞ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
      const createFileResult = await this.client!.callTool({
        name: 'github_create_file',
        arguments: {
          owner: process.env.GITHUB_REPO_OWNER || 'your-username',
          repo: process.env.GITHUB_REPO_NAME || 'your-repo',
          path: `generated/${fileName}`,
          message: `feat: AI-generated code for task - ${taskDescription.slice(0, 50)}...`,
          content: Buffer.from(fileContent).toString('base64'),
          branch: 'main'
        }
      })

      // –°–æ–∑–¥–∞–µ–º README —Ñ–∞–π–ª
      const readmeContent = this.createReadmeContent(taskDescription, analysis, fileName)
      
      await this.client!.callTool({
        name: 'github_create_file',
        arguments: {
          owner: process.env.GITHUB_REPO_OWNER || 'your-username',
          repo: process.env.GITHUB_REPO_NAME || 'your-repo',
          path: `generated/${fileName.replace('.py', '.md')}`,
          message: `docs: Add README for ${fileName}`,
          content: Buffer.from(readmeContent).toString('base64'),
          branch: 'main'
        }
      })

      // –°–æ–∑–¥–∞–µ–º Pull Request
      const prResult = await this.client!.callTool({
        name: 'github_create_pull_request',
        arguments: {
          owner: process.env.GITHUB_REPO_OWNER || 'your-username',
          repo: process.env.GITHUB_REPO_NAME || 'your-repo',
          title: `ü§ñ AI Generated: ${taskDescription.slice(0, 60)}...`,
          body: this.createPullRequestBody(taskDescription, analysis, fileName),
          head: 'main',
          base: 'main'
        }
      })

      return {
        title: `ü§ñ AI Generated: ${taskDescription.slice(0, 60)}...`,
        description: this.createPullRequestBody(taskDescription, analysis, fileName),
        url: `https://github.com/${process.env.GITHUB_REPO_OWNER}/${process.env.GITHUB_REPO_NAME}/pull/1`,
        branch: 'main',
        number: 1
      }

    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è PR —á–µ—Ä–µ–∑ MCP:', error)
      
      // Fallback –∫ –º–æ–∫-—Å–µ—Ä–≤–∏—Å—É
      return {
        title: `ü§ñ AI Generated: ${taskDescription.slice(0, 60)}...`,
        description: `AI generated code for task: ${taskDescription}`,
        url: `https://github.com/example/repo/pull/123`,
        branch: `feature/ai-generated-${fileName.replace('.py', '')}`,
        number: 123
      }
    }
  }

  private createFileContent(taskDescription: string, analysis: string, generatedCode: string): string {
    return `"""
AI Generated Code
================

Task Description: ${taskDescription}

Analysis:
${analysis}

Generated on: ${new Date().toISOString()}
"""

${generatedCode}
`
  }

  private createReadmeContent(taskDescription: string, analysis: string, fileName: string): string {
    return `# AI Generated Code: ${fileName}

## Task Description
${taskDescription}

## Analysis
${analysis}

## Generated Code
The generated code is available in \`${fileName}\`.

## Usage
\`\`\`bash
python ${fileName}
\`\`\`

## Dependencies
Check the comments at the top of the file for required dependencies.

---
*This code was automatically generated by AI Task Processor using GigaChat API and MCP.*
`
  }

  private createPullRequestBody(taskDescription: string, analysis: string, fileName: string): string {
    return `## ü§ñ AI Generated Pull Request (via MCP)

### Task Description
${taskDescription}

### Analysis
${analysis}

### Generated Files
- \`generated/${fileName}\` - Main implementation
- \`generated/${fileName.replace('.py', '.md')}\` - Documentation

### What was done
- ‚úÖ Analyzed the technical requirement using GigaChat
- ‚úÖ Generated working Python code
- ‚úÖ Added error handling and documentation
- ‚úÖ Created comprehensive README
- ‚úÖ Created Pull Request via MCP

### Next Steps
- [ ] Review the generated code
- [ ] Test the implementation
- [ ] Add any necessary modifications
- [ ] Merge if approved

---
*This PR was automatically created by AI Task Processor using MCP (Model Context Protocol).*
`
  }

  async disconnect() {
    if (this.client && this.isConnected) {
      await this.client.close()
      this.isConnected = false
      console.log('üîå MCP GitHub —Å–µ—Ä–≤–µ—Ä –æ—Ç–∫–ª—é—á–µ–Ω')
    }
  }
} 